# HTTP篇

### 状态码

+ 1XX：提示信息，**中间状态**，还需要后续处理

+ 2XX：成功

  + 「200 OK」是最常见的成功状态码，表示一切正常。
  + 「204 No Content**」与 200 OK 基本相同，但**响应头没有 body 数据**。
  + 「206 Partial Content**」是应用于 HTTP **分块下载或断点续传**，**表示响应返回的 body 数据并不是资源的全部，而是其中的一部分**，也是服务器处理成功的状态。

+ 3XX：重定向

  + 「301 Moved Permanently」表示**永久重定向**，说明请求的资源已经不存在了，需改用新的 URL

  + 「302 Found」表示**临时重定向**，说明请求的资源还在，但暂时需要用另一个 URL 来访问。

    > 301、302的响应头里使用Location字段，指明要跳转的URL。

  + 「**304 Not Modified**」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是**告诉客户端可以继续使用缓存资源**，用于缓存控制。。

+ 4XX：**客户端错误**，请求报文出错，服务器无法处理请求

  + 「400 Bad Request**」表示客户端请求的**报文有错误**，但只是个笼统的错误。
  + 「403 Forbidden**」表示**服务器禁止访问**资源，并不是客户端的请求出错。
  + 「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

+ 5XX：服务器错误，服务器在处理请求时内部出错

  + 「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
  + 「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。
  + 「**502 Bad Gateway**」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
  + 「503 Service Unavailable」表示**服务器当前很忙**，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。

### Http常见字段

1. host字段：服务器域名

2. Content-Length：服务器返回携带，表明数据长度

3. Connection：客户端要求服务器使用HTTP长连接。

   + HTTP/1.1版本默认长连接，但需要Connection字段值为Keep-Alive

4. Content-Type：服务器告诉客户端是什么数据格式

5. Content-Encoding：数据压缩方法，如gzip

   Accept-Encoding：客户端在请求时说明自己可以接受哪些压缩方法

### GET与POST

**GET 的语义是从服务器获取指定的资源**；**POST 的语义是根据请求负荷（报文body）对指定的资源做出处理**。

+ 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。
+ 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。

**GET 方法就是安全且幂等的**（所以浏览器可以缓存）

### HTTP缓存技术

1. 强制缓存：只要浏览器里的缓存没过期，就使用浏览器的本地缓存。

   Cache-Control：一个相对时间。优先级更高

   Expire时：一个绝对时间，优先级低于Cache-Control

2. 协商缓存：请求的响应码是304。有如下两种实验

   1. 请求头部中的 `If-Modified-Since` 字段与响应头部中的 `Last-Modified` 字段（标记资源最后修改时间）。根据时间来
   2. 请求头部中的 `If-None-Match` 字段与响应头部中的 `ETag` 字段（唯一表示响应资源）。根据唯一表示

   + ETag的优先级更高

+ **协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求**

<img src="./%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C.assets/image-20240316%E4%B8%8B%E5%8D%8893513013.png" alt="image-20240316下午93513013" style="zoom:50%;" />

+ 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；

+ 当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：

  + 如果没有过期，则直接使用本地缓存；
  + 如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；

+ 服务器再次收到请求后，

  会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较

  ：

  + **如果值相等，则返回 304 Not Modified，不会返回资源**；
  + 如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；

+ 如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。

## HTTP 1.1/2.0/3.0

简单、灵活易于扩展、应用广泛跨平台；比如HTTPS就是HTTP与TCP之间增加了SSL/TLS安全传输层

#### HTTP/1.1 缺点

1. 无状态：好处是服务器不会记忆HTTP状态，不需要额外资源，减轻服务器负担；坏处是完成有关性操作比较麻烦（例如登录->添加购物车->下单->结算->支付）
   + 使用**Cookie**技术解决
2. 明文传输：好处是便于调试，坏处是信息不安全
3. **不安全**：
   1. 通信使用明文，有**窃听**风险
   2. 不验证通信方身份，可能遭遇**伪装**（比如假淘宝）
   3. 无法证明报文完整性，可能遭到**篡改**（比如广告）
4. 队头阻塞：当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「**队头阻塞**」

+ 长连接带来的好处：可以管道网络传输（不需要等待响应即可发送下条请求，减少整体的响应时间）（**但默认不开启，且浏览器大都不支持**）

#### HTTP和HTTPs

+ HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输
+  HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
+ HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
+ HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的

为了继绝窃听、篡改、冒充风险，HTTPS利用**混合加密（机密性）、摘要算法（完整性）、数字证书（公钥）**实现了**信息加密、校验机制、身份证书**

+ HTTPS 采用的是**对称加密**和**非对称加密**结合的「混合加密」方式，在**通信建立前**采用**非对称加密**的方式**交换「会话秘钥」**，后续就不再使用非对称加密。在**通信过程中**全部使用**对称加密**的「会话秘钥」的方式加密明文数据

+ **用摘要算法（哈希函数）来计算出内容的哈希值**，这个**哈希值是唯一的，且无法通过哈希值推导出内容**。可以确保内容不被篡改（但可能<u>内容+哈希</u>一起被中间人篡改）

  + **公钥加密，私钥解密**：保证内容传输的安全
  + **私钥加密，公钥解密**：保证消息不会被冒充。
    + 此处对内容的哈希值加密

+ 数字证书

  <img src="./%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C.assets/image-20240316%E4%B8%8B%E5%8D%88100659435.png" alt="image-20240316下午100659435" style="zoom:50%;" />

### HTTP/1.1 相比 HTTP/1.0 提高了什么性能？

+ 使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。
+ 支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

仍然不足之处：

+ 请求 / 响应**头部**（Header）未经压缩就发送，首部信息越多延迟越大。**只能压缩 `Body` 的部分**；
+ 发送冗长的首部。每次互相发送相同的首部造成的浪费较多；
+ **服务器是按请求的顺序响应**的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是**队头阻塞**；
+ **没有请求优先级控制**；
+ 请求只能从客户端开始，**服务器只能被动响应**。

###  HTTP/2 相比 HTTP/1.1 性能上的改进：

+ HTTP/2在HTTPS上改进，安全有保障
+ 头部压缩：**同时发出多个请求**，他们的头是一样的或是相似的，那么，协议会帮你**消除重复的部分**。
+ 二进制格式：HTTP/1.1纯文本形式报文，HTTP/2采用了**二进制格式**，头信息和数据体都是二进制，并且统称为帧（frame）：**头信息帧（Headers Frame）和数据帧（Data Frame）**。
+ 并发传输：引出了 Stream 概念，多个 Stream 复用在一条 TCP 连接。
+ 服务器主动推送资源：客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。

不足之处：

HTTP/2 通过 Stream 的并发能力，解决了 HTTP/1 **队头阻塞**的问题，看似很完美了，但是 HTTP/2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，**而是在 TCP 这一层**。

### HTTP/3

+ HTTP/1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是**没有解决响应的队头阻塞**，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。
+ HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是**一旦发生丢包，就会阻塞住所有的 HTTP 请求**，这属于 TCP 层队头阻塞。

HTTP/2 队头阻塞的问题是因为 TCP，所以 **HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！**

基于 UDP 的 **QUIC 协议** 可以实现类似 TCP 的可靠性传输。QUIC 有以下 3 个特点。

+ 无队头阻塞：丢包时只会阻塞自己这个流

+ 更快的连接建立：对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，难以合并，先TCP握手，再TLS握手。但是 HTTP/3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS/1.3，**因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商**。甚至，在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。

  <img src="./%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C.assets/image-20240320%E4%B8%8B%E5%8D%8814741968.png" alt="image-20240320下午14741968" style="zoom:50%;" />

+ 连接迁移：基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。**当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接**，而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过**连接 ID** 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了**连接迁移**的功能。

## 如何优化HTTP/1.1

### 避免发送HTTP请求

一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都**缓存在本地，采用缓存技术**。服务器在发送 HTTP 响应时，会估算一个过期的时间放在响应头，客户端在查看响应头部的信息时，一旦发现缓存的响应是过期的，则就会重新发送网络请求。

### 减少HTTP请求次数

+ ***减少重定向**请求次数*；
+ ***合并请求***；比如多个小图片和并成为大图片
+ ***延迟发送请求***；采用**按需获取**的方式，不需要获取全部信息

### 减少HTTP响应的数据大小

**对资源进行压缩**

+ 有损压缩
+ 无损压缩

